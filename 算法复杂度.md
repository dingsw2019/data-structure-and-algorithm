内容来源
    https://www.jianshu.com/p/f4cca5ce055a

## 什么是时间复杂度 ?
算法的时间复杂度, 用来度量算法的运行时间, 记作: T(n) = O(f(n))
它表示随着输入大小 n 的增大, 算法执行需要的时间的增长速度可以用f(n)来描述


## 

我们假设计算机运行一行基础代码, 需要 1 次运算的时间

1. 所有常数时间内完成的, 复杂度记为 O(1) 
```
// 需要 2 次运行时间
int aFunc(void) {
    printf("Hello, World!\n");      //  需要执行 1 次
    return 0;       // 需要执行 1 次
}

```

2. 幂次增长,比如 n^2,复杂度记为 O(n^2); n^3 复杂度记为 O(n^3)
```
// 时间复杂度为 O(n × 1)，即 O(n)
void aFunc(int n) {
    for(int i = 0; i < n; i++) {         // 循环次数为 n
        printf("Hello, World!\n");      // 循环体时间复杂度为 O(1)
    }
}

// 时间复杂度为 O(n × n × 1)，即 O(n^2)
void aFunc(int n) {
    for(int i = 0; i < n; i++) {         // 循环次数为 n
        for(int j = 0; j < n; j++) {       // 循环次数为 n
            printf("Hello, World!\n");      // 循环体时间复杂度为 O(1)
        }
    }
}
```

3. 顺序执行的语句, 取最大的时间复杂度
```
// 时间复杂度为 max(O(n^2), O(n)), 即 O(n^2)
void aFunc(int n) {
    // 第一部分时间复杂度为 O(n^2)
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            printf("Hello, World!\n");
        }
    }
    // 第二部分时间复杂度为 O(n)
    for(int j = 0; j < n; j++) {
        printf("Hello, World!\n");
    }
}

// 时间复杂度为 max(O(n^2), O(n)), 即 O(n^2)
void aFunc(int n) {
    if (n >= 0) {
        // 第一条路径时间复杂度为 O(n^2)
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                printf("输入数据大于等于零\n");
            }
        }
    } else {
        // 第二条路径时间复杂度为 O(n)
        for(int j = 0; j < n; j++) {
            printf("输入数据小于零\n");
        }
    }
}
```

## 练习
```
void aFunc(int n) {
    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            printf("Hello World\n");
        }
    }
}
```
当 i = 0 时，内循环执行 n 次运算，当 i = 1 时, 内循环执行 n - 1 次运算……当 i = n - 1 时，内循环执行 1 次运算。
所以，执行次数 T(n) = n + (n - 1) + (n - 2)……+ 1 = n(n + 1) / 2 = n^2 / 2 + n / 2。
根据上文说的 大O推导法 可以知道，此时时间复杂度为 O(n^2)。




```
void aFunc(int n) {
    for (int i = 2; i < n; i++) {
        i *= 2;
        printf("%i\n", i);
    }
}
```
假设循环次数为 t，则循环条件满足 2^t < n。
可以得出，执行次数t = log(2)(n)，即 T(n) = log(2)(n)，可见时间复杂度为 O(log(2)(n))，即 O(log n)


```
long aFunc(int n) {
    if (n <= 1) {
        return 1;
    } else {
        return aFunc(n - 1) + aFunc(n - 2);
    }
}
```
显然运行次数，T(0) = T(1) = 1，同时 T(n) = T(n - 1) + T(n - 2) + 1，这里的 1 是其中的加法算一次执行。
显然 T(n) = T(n - 1) + T(n - 2) 是一个斐波那契数列，通过归纳证明法可以证明，当 n >= 1 时 T(n) < (5/3)^n，同时当 n > 4 时 T(n) >= (3/2)^n。
所以该方法的时间复杂度可以表示为 O((5/3)^n)，简化后为 O(2^n)。